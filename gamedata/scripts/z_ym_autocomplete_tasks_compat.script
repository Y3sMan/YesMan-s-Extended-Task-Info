
local function dbg_print(msg,...)
    if not ym_debug then return end

    ym_debug.set_modname("AT YM_EXTENDED_TASK_INFO COMPENSATION COMPATIBILITY")
    ym_debug.dbg_print(msg,...)
		--exec_console_cmd("flush")
end

local function newline()
    printf("\\n")
end

local gc = game.translate_string
local ym_utils = ym_eti_utils
local parse_keys   = utils_data.parse_string_keys




-- TODO: To handle item compensation, the compensation would have to be summed with the other potential reward calculations
if ym_eti_utils and z_autocomplete_tasks_core then
    printf("! Monkey Patching zz_ym_extended_task_info for Autocomplete Tasks")

    --#region imports
    -- local remove_task_func = zz_ym_extended_task_info.ym_remove_supported_task_func
    local add_task_func
    local at_utils
    local get_base_cost
    local get_mcm_config
    local isATEnabled
    local isCompensate
    local should_autocomplete
    local org_get_fetch_reward


    local function imports()
         add_task_func = ym_utils.ym_add_supported_task_func
         at_utils = autocomplete_tasks_utils
         get_base_cost = at_utils.get_base_cost
         get_mcm_config = autocomplete_tasks_mcm.get_config
         isATEnabled = get_mcm_config("at_general", "enable")
         isCompensate = get_mcm_config("at_general", "compensate_item_rewards")
         should_autocomplete = z_autocomplete_tasks_core.should_autocomplete
         org_get_fetch_reward = ym_utils.ym_get_fetch_reward
    end

    imports()
    --#endregion

    function is_listed(list, tid)
        if list == "none" then return false end

        local tids = str_explode(list, ",")
        for i = 1, #tids do
            if tids[i] == tid then
                return true
            end
        end

        return false
    end


    local _AT_task_cache = {}
    function can_autocomplete(task_id)
        -- Check if task is already cached
        if not _AT_task_cache[task_id] then
            -- Check if task is defined in the task manager
            local parsed_data = utils_data.parse_ini_section_to_array(task_manager.task_ini, task_id)
            if not parsed_data then
                dbg_print("Unable to autocomplete task: %s", task_id)
            end

            -- Add task to cache
            _AT_task_cache[task_id] = parsed_data or {}
        end

        local tsk = _AT_task_cache[task_id]

        -- Check if task is not a storyline task
        if (tsk.storyline) and (tsk.storyline == "true") then return false end

        -- Check if task is whitelisted
        if is_listed(get_mcm_config("at_other", "whitelist"), task_id) then return true end

        -- Check if task is blacklisted
        if is_listed(get_mcm_config("at_other", "blacklist"), task_id) then return false end

        -- Check if task has a whitelisted target functor
        if not tsk.target_functor then return false end
        if not z_autocomplete_tasks_core.should_complete_by_task_functor(tsk.target_functor) then return false end

        return true
    end


    function ym_reward_item_compensation(task_id)
        if not task_id then return end
        imports()

        -- if compenstation is not enabled in AT, then return 0,0; this will not add to the sum rewards
        if (not isATEnabled) or (not isCompensate) then
            return 0, 0 
        end

        local itm_tbl = ym_utils.ym_get_reward_item_arg(task_id)
        if not itm_tbl then return end

        local money_tbl = {}
        local lowest_reward = math.huge
        local highest_reward = -math.huge
        if itm_tbl then
            for k, v in pairs( itm_tbl ) do
                dbg_print("v = " .. tostring(v))
                local cost = at_utils.get_base_cost(v)
                dbg_print("cost of v = " .. tostring(cost))

                if (cost > highest_reward) then
                    highest_reward = cost 
                end
                if (cost < lowest_reward) then
                    lowest_reward = cost 
                end

                money_tbl[v] = cost
            end
        end

        dbg_print("lowest_reward = %s, highest_reward = %s", lowest_reward, highest_reward)


        return lowest_reward, highest_reward -- return min_reward, max_reward
    end
    --#endregion

    -- Function to add item compensation information to reward dialog
    function ym_setup_reward_items_info(task_id)
        imports()
        newline()
        dbg_print("YM_SETUP_REWARD_ITEMS_INFO")


        dbg_print("task_id, should_autocomplete = %s, %s", task_id, should_autocomplete(task_id, 0))
        dbg_print("task_id, can_autocomplete = %s, %s", task_id, can_autocomplete(task_id))
        dbg_print("task has reward item =%s", ym_utils.ym_does_task_have_reward_item(task_id))

        -- Check if this task has been worked on
        -- if not, continue
        -- FIXME: Check that the same task_id, after being refreshed, correctly gets processed
        if not _AT_task_cache[task_id] then
            -- Check if task is defined in the task manager
            local parsed_data = utils_data.parse_ini_section_to_array(task_manager.task_ini, task_id)

            -- Add task to cache
            _AT_task_cache[task_id] = parsed_data or {}
        else
            return 0, 0
        end


        -- If Autocomplete is disabled
        -- If item compensation is disabled
        -- or the task does not even have a reward_item or reward_random_item function
        if ((not isATEnabled) or (not isCompensate) or (not can_autocomplete(task_id)) or not ym_utils.ym_does_task_have_reward_item(task_id)) then
            return 0, 0 
        end

        local s = ym_utils.ym_list_reward_items(task_id)
        dbg_print("s = %s", s)

        -- get the total minimum and maximum item compensation
        local min_comp, max_comp = ym_reward_item_compensation(task_id)

        ym_utils.ym_set_reward_caption(gc("st_ym_eti_at_caption"))

        local tbl_keys = ym_utils.get_generic_tbl_keys()
        tbl_keys["min_compensation"] = min_comp or 0
        tbl_keys["max_compensation"] = max_comp or 0

        -- Edit the dialog text
        -- First edit the "Min" line
        local org_min  = ym_utils.ym_get_reward_text_min()
        local new_min = gc("st_ym_eti_at_min_compensation")
        org_min = org_min .. new_min
        local s        = parse_keys(org_min, tbl_keys)
        dbg_print("new min text = %s",s)
        ym_utils.ym_set_reward_text_min(s)

        -- Then edit the "Max" line
        local org_max = ym_utils.ym_get_reward_text_max()
        local new_max = gc("st_ym_eti_at_max_compensation")
        org_max = org_max .. new_max 
        s = parse_keys(org_max, tbl_keys)
        dbg_print("new max text = %s",s)
        ym_utils.ym_set_reward_text_max(s)

        return 0, 0
    end



    local funcs = ym_utils.ym_get_supported_task_funcs()
    local org_rwd_func = funcs["reward_item,"]


    add_task_func("reward_item,", { ym_setup_reward_items_info , org_rwd_func })
    add_task_func("reward_random_item,", { ym_setup_reward_items_info, org_rwd_func })

    -- Add support for all kinds of tasks that may reward the player in multiple different methods
    add_task_func("fetch_reward_and_remove,", { ym_setup_reward_items_info , funcs["fetch_reward_and_remove,"] })
    add_task_func("reward_random_money,", { ym_setup_reward_items_info, funcs["reward_random_money,"] })
    add_task_func("reward_random_money_by_dist", { ym_setup_reward_items_info, funcs["reward_random_money_by_dist"] })
    add_task_func("reward_money,", { ym_setup_reward_items_info , funcs["reward_money,"] })
    add_task_func("tasks_recover_item_on_corpse,[2] = reward,", { ym_setup_reward_items_info, funcs["tasks_recover_item_on_corpse,[2] = reward,"] })


    -- function on_game_start()
    --     RegisterScriptCallback("on_game_load", override)
    -- end
end
