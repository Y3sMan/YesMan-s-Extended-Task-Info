
local function dbg_print(msg,...)
    if not ym_debug then return end

    ym_debug.set_modname("AT YM_EXTENDED_TASK_INFO COMPENSATION COMPATIBILITY")
    ym_debug.dbg_print(msg,...)
		--exec_console_cmd("flush")
end


-- Gets arguments for "reward_item" and "random_reward_item" funcs in task config
function ym_get_reward_item_arg(task_id)
    newline()
    dbg_print("GET_REWARD_ITEM_ARG")
    local condlist = ym_utils.get_on_comp_condlist(task_id)

    local reward_itms_tbl = nil

    local visited = {}
    local breakFlag = false
    local function deepprint(tbl)
        for k, v in pairs(tbl) do
            if breakFlag then return end

            -- dbg_print("key = " .. tostring(k))
            -- dbg_print("val = " .. tostring(v))

            if type(v) == 'table' then
                if visited[v] == true then return end
                visited[v] = true

                deepprint(v)
            else
                if (string.find(tostring(v), "reward_item") or string.find(tostring(v), "reward_random_item")) then
                    dbg_print("found reward_item or reward_random_item at key = %s", k)
                    reward_itms_tbl = tbl[3]
                    -- dbg_print("reward_item table = " .. tostring(table_dump(tbl[k+2])))

                    breakFlag = true
                    break
                end
            end

        end
    end

    deepprint(condlist)
    return reward_itms_tbl 
end


-- TODO: To handle item compensation, the compensation would have to be summed with the other potential reward calculations
if ym_eti_utils and z_autocomplete_tasks_core then
    printf("! Monkey Patching zz_ym_extended_task_info for Autocomplete Tasks")

    local ym_utils = ym_eti_utils 
    local org_get_fetch_reward = ym_utils.ym_get_fetch_reward
    local add_task_func = ym_utils.ym_add_supported_task_func

    local at_utils = autocomplete_tasks_utils
    local get_base_cost = at_utils.get_base_cost
    local get_mcm_config = autocomplete_tasks_mcm.get_config
    -- local remove_task_func = zz_ym_extended_task_info.ym_remove_supported_task_func

    ym_reward_item_compensation = function(task_id)
        if not task_id then return end

        local itm_arg = ym_eti_core.get_reward_item_arg(task_id)
        if not itm_arg then return end

        local money_tbl = {}
        local lowest_reward = math.huge
        local highest_reward = -math.huge
        if itm_arg then
            for k, v in pairs( itm_arg ) do
                dbg_print("v = " .. tostring(v))
                local cost = utils.get_base_cost(v)
                dbg_print("cost of v = " .. tostring(cost))

                if (cost > highest_reward) then
                    highest_reward = cost 
                end
                if (cost < lowest_reward) then
                    lowest_reward = cost 
                end

                money_tbl[v] = cost
            end
        end


    function ym_setup_reward_items_info(task_id)
        if (not isATEnabled) or (not isCompensate) then
            return 0, 0 
        end

        local min_comp, max_comp = ym_reward_item_compensation(task_id)
        ym_utils.ym_set_reward_caption("reward item test 1")

        local tbl_keys = {
            ["min_compensation"] = min_comp,
            ["grn_text"] = grn_text,
            ["max_compensation"] = max_comp,
            ["clr_text"] = clr_txt,
        }

        local org_min  = ym_utils.ym_get_reward_text_min()
        org_min = org_min .. " ( +%$grn_text$min_compensation$clr_text)"
        local s        = parse_keys(org_min, tbl_keys)
        ym_utils.ym_set_reward_text_min(s)

        local org_max = ym_utils.ym_get_reward_text_max()
        org_max = org_max .. " ( +%$grn_text$max_compensation$clr_text)"
        s = parse_keys(org_max, tbl_keys)
        ym_utils.ym_set_reward_text_max(s)
        -- save_var(db.actor, (task_id .. "_ym_reward_caption"), "Reward (with item compensation):")

        return 0, 0
    end

    function ym_reward_item_caption()
        return "Reward (with item compensation):"
    end

    function ym_reward_item_text_min()
        return gc("ym_ui_reward_min") .. " (+%$min_comp)"
    end

    function ym_reward_item_text_max()
        return gc("ym_ui_reward_max") .. " (+%$max_comp)"
    end

    function ym_reward_item_text(min_cost, max_cost,min_comp, max_comp)
        local s = ym_reward_item_text_min() .. "\\n" .. ym_reward_item_text_max()
        local tbl_keys = {
            ["min"] = min_cost,
            ["max"] = max_cost,
            ["min_comp"] = min_comp,
            ["max_comp"] = max_comp,
            ["grn_text"] = grn_text,
            ["new_line"] = "\\n",
            ["clr_number"] = clr_txt,
            ["clr_text"] = clr_txt,
            ["ylw_text"] = ylw_text,
        }
        return parse_keys(s, tbl_keys)
    end

        -- end

            local org_combined_cap_and_reward = ym_utils.combined_caption_and_reward
            function ym_eti_utils.combined_caption_and_reward(min, max, task_id)
                if not ym_utils.ym_does_task_have_reward_item(task_id) then return org_combined_cap_and_reward(min, max, task_id) end

                ym_utils.ym_reset_reward_caption()
                local org_cap = ym_utils.ym_get_reward_caption()
                if (string.find(org_cap, " (with item compensation)")) then
                    
                end
                local new_cap = org_cap .. " (with item compensation)"
                ym_utils.ym_set_reward_caption(new_cap)

                return org_combined_cap_and_reward(min, max)
            end
        end
    end


    add_task_func("reward_item,", ym_reward_item_compensation)
    add_task_func("reward_random_item,", ym_reward_item_compensation)


    function on_game_start()
        RegisterScriptCallback("on_game_load", override)
    end
end
