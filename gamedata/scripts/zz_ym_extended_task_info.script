--#region debug helpers
local function dbg_print(msg,...)
    if not ym_debug then return end

    ym_debug.set_modname("YM_EXTENDED_TASK_INFO")
    ym_debug.dbg_print(msg,...)
		--exec_console_cmd("flush")
end

-- local function dbg_dump(o)
--     if not ym_debug then return "" end

--     return ym_debug.dbg_dump(o)
-- end
--#endregion

-- #region helper functions
local parse_keys = utils_data.parse_string_keys
local gc = game.translate_string
local newline = function()
    printf("\n")
end
-- imports
local utils = ym_eti_utils


if z_taskboard_overrides then
    dbg_print("PDA TASKBOARD override loaded")
    local pda_taskboard_create_overrides = z_taskboard_overrides.create_overrides
    -- pda_taskboard_create_overrides()
    -- function on_game_start()
    --     RegisterScriptCallback("on_game_load", pda_taskboard_create_overrides)
    -- end
end


--#region PDA TASKBOARD COMPATIBILITY ------
-- Section taken from extended task info by Coverdrave

--[[
	Worth to note that task_id isn't a unique id for each instance of a quest,
	you can think of it as a "template" of a quest.
	Therefore, values in the following table can be overriden,
	but this doesn't seem to be an issue since the previous value has already been used.

	Weird Tasks Framework, however, has an unique id for each quest
	since it concatenates the 'key' (CACHE.description_key) and the
	taskgiver's id.
--]]

-- key = task_id, value = news_text

if z_taskboard_overrides then
    newline()
    dbg_print("PDA TASKBOARD override loaded")
    local tskbrd = z_taskboard_overrides
    -- local pda_taskboard_create_overrides = tskbrd.create_overrides
    
    -- imported from z_taskboard_overrides
    -- local original_give_talk_message2 = db.actor.give_talk_message2
    -- db.actor.give_talk_message2 = function (...)
    --     if ActorMenu.get_pda_menu():IsShown() then
    --         local _, task_title, task_details, task_icon = ...
    --         table.insert(tskbrd.tasks_info, {
    --             task_title = task_title,
    --             task_details = task_details,
    --             task_icon = task_icon
    --         })
    --     else
    --         original_give_talk_message2(...)
    --     end

    -- end

end


if ui_pda_taskboard_tab and ui_pda_taskboard_tab.clear_cached_data then
    local original_clear_cached_data = ui_pda_taskboard_tab.clear_cached_data

    -- Clear cache table on taskboard clear
    function ui_pda_taskboard_tab.clear_cached_data()
        original_clear_cached_data()
        utils.ym_cached_tasks_text = {}
    end
end

--#endregion
--#endregion

-- REWARDS IN DIALOG
--#region

-- TODO: Add reward message to message history
-- ? TODO: Handle dynamic tasks from imporant npcs
-- * Taskboard handles it mostly fine
--// ! PDA Taskboard messages very garbled
--//  ? my fault?
--// * Looks like just the Messages portion is messed up?

-- TODO: patches for artifact fetch task fails
-- Gives double "you have x in inventory messages"


--// TODO: Investigate multifetch_remove function for compatibility
--#region FETCH
local org_fetch_postpone = tasks_fetch.postpone_fetch_for_next_frame
local org_setup_fetch_task = xr_effects.setup_fetch_task
function xr_effects.setup_fetch_task(actor, npc, p)
    org_setup_fetch_task(actor,npc,p)

	local npc = get_speaker(true)
	local npc_id  = npc and npc:id()
    local sec = load_var(db.actor, npc_id .. "_fetch", "")
    local cnt = sec and load_var(db.actor, npc_id .. "_count") or 1
    local task_id = p[1]

    if not task_id then return end
    if string.find(task_id, "_fetch") then
        task_id = string.sub(task_id, 1, -7) or ""   -- because it ends with fetch
    end

    -- local function postpone(task_id, section, amount)
    --     if not task_id then return end
    --     if string.find(task_id, "_fetch") then
    --         task_id = string.sub(task_id,1,-7) or "" -- because it ends with fetch
    --     end

    --     if (utils.is_pda_taskboard_active()) or (not utils.is_supported_task(task_id)) then
    --         dbg_print("Not a supported task")
    --         -- cache_task_text(task_id, news_caption, news_text)
    --         org_fetch_postpone(task_id, section, amount)
    --         return true
    --     end

    --     local min, max = utils.calc_reward_money(task_id)
    --     local news_caption = utils.ym_get_reward_caption() or "error"
    --     local news_text = utils.format_reward_string(min, max)

	-- 	db.actor:give_talk_message2(news_caption, news_text, "utils.ym_get_reward_icon()", "iconed_answer_item")
    --     return true
    -- end

    local function postpone(task_id, section, amount)
        if (utils.is_pda_taskboard_active()) or (not utils.is_supported_task(task_id)) then
            -- cache_task_text(task_id, news_caption, news_text)
            org_fetch_postpone(task_id, section, amount)
            return true
        end

        return utils.generic_postpone(task_id)
    end


	CreateTimeEvent(2,"setup_fetch_task", 0, postpone, task_id, sec, cnt)
end
--#endregion




--// TODO: finish the rest of the types of dynamic tasks
--// TODO: Test RESCUE
--#region RESCUE AGENT
local org_rescue_setup = tasks_agent_rescue.setup_spy_task
function tasks_agent_rescue.setup_spy_task(actor,npc, p)
	if not (p and p[1]) then
		return false
	end
	local task_id = p[1]

    newline()
    dbg_print("RESCUE")
    org_rescue_setup(actor, npc, p)


	if not utils.is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		-- RemoveTimeEvent(0,"on_init_delivery_task") 
		RemoveTimeEvent(2,"setup_spy_task") 
	end

    CreateTimeEvent(2,"setup_spy_task",0,utils.generic_postpone,task_id)
end

--#endregion

-- TODO: Test ASSAULT 
--#region ASSAULT   
local org_assault_setup = xr_effects.setup_assault_task
function xr_effects.setup_assault_task(actor, npc, p)
    newline()
    dbg_print("SETUP_ASSAULT_TASK init")
	if not (p and p[1]) then
		return false
	end

	local task_id = p[1]

    org_assault_setup(actor, npc, p)

    if not utils.is_pda_taskboard_active then 
		RemoveTimeEvent(2,"setup_assault_task") 
    end

    CreateTimeEvent(2,"setup_assault_task",0,utils.generic_postpone,task_id)
end
--#endregion

--// TODO: Test BOUNTY

--#region BOUNTY
local org_bounty_setup = xr_effects.setup_bounty_task
local org_bounty_postpone = function(task_id, target_id)
    local news_caption = game.translate_string(task_manager.task_ini:r_string_ex(p[1], "title")) or "error"
    local news_text = game.translate_string("st_mm_new_game_name") .. " " .. se_target:character_name() .. "\\n " .. game.translate_string("st_mm_new_game_faction_2") .. " " .. game.translate_string(se_target:community()) .. "\\n " .. game.translate_string("st_location") .. " " .. game.translate_string(level_target)
    db.actor:give_talk_message2(news_caption, news_text, se_target:character_icon(), "iconed_answer_item")
    return true
end

function xr_effects.setup_bounty_task(actor, npc, p)
-- function tasks_bounty.setup_bounty_task(actor, npc, p)
    newline()
    dbg_print("BOUNTY")
    org_bounty_setup(actor, npc, p)

    local task_id = p[1]
    if not task_id then return end

	if not utils.is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		RemoveTimeEvent(2,"setup_bounty_task") 
	end

	-- if is_pda_taskboard_active() then return end

    
	CreateTimeEvent(2,"setup_bounty_task",0,utils.generic_postpone,task_id)
end

--#endregion

-- TODO: Do dominance tasks
--// TODO: Test DOMINANCE
--#region DOMINANCE
local org_dominance_setup = tasks_dominance.setup_dominance_task

--#endregion

-- TODO: Test RIOC
--#region RECOVER ITEM ON CORPSE tasks
--* Note: RIOC tasks have the reward hard-coded into tasks_recover_item_on_corpse:
--* min = 5000
--* max = 7500
local org_recover_item_on_corpse_setup = tasks_recover_item_on_corpse.on_descr

local function org_rioc_postpone(x)
    local news_caption = ''
    local news_icon = 'ui_pda2_mtask_overlay'
    local news_text = game.translate_string("st_location") .. " " .. game.translate_string(x)
    db.actor:give_talk_message2(news_caption, news_text, news_icon, "iconed_answer_item")
    return true
end

function tasks_recover_item_on_corpse.on_descr(a,b,c)
    newline()
    dbg_print("RIOC")

    org_recover_item_on_corpse_setup(a,b,c)

    local task_id = c[1]
    if not task_id then return end

	if not utils.is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		RemoveTimeEvent(2,"on_desxr_rioc") 
	end

	-- local function postpone_for_next_frame(x)
    --     dbg_print("x = %s", x)
    --     local min, max = utils.ym_get_rioc_reward(task_id)

    --     local news_caption = utils.ym_get_reward_caption()
	-- 	local news_icon = utils.ym_get_reward_icon()
	-- 	local news_text = utils.format_reward_string(min, max)


    --     if  utils.is_pda_taskboard_active then 
    --         -- cache_task_text( news_caption, news_text)
    --         return true
    --     end

        
	-- 	db.actor:give_talk_message2(news_caption, news_text, news_icon, "iconed_answer_item")
	-- 	return true
	-- end

    local function postpone(x)

        if (utils.is_pda_taskboard_active()) or (not utils.is_supported_task(task_id)) then
            dbg_print("RIOC not supported")
            -- cache_task_text(task_id, news_caption, news_text)
            org_rioc_postpone(x)
            return true
        end
        return utils.generic_postpone(task_id)
    end

	CreateTimeEvent(2,"on_descr_rioc",0,postpone, utils_data.read_from_ini(task_manager.task_ini,c[1],'level_name','string'))
end
--#endregion

-- TODO: Test SEARCH
--#region SEARCH STASH
local org_stash_setup = xr_effects.drx_sl_create_quest_stash
function xr_effects.drx_sl_create_quest_stash( actor, npc, p )
	if not (p and p[1] and p[2]) then
		return
	end
	if not utils.is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		RemoveTimeEvent(2,"setup_bounty_task") 
	end

    if not org_stash_setup then return end
    org_stash_setup(actor, npc, p)

    local task_id = p[1]

	CreateTimeEvent(2,"setup_bounty_task",0,utils.generic_postpone, task_id)
end

--#endregion

--// TODO: Test DELIVERY
--// ! BUG: reward estimate is off by some varying factor, most likely the distance (sweets) factor
--* Reward estimate was off because of the random number generator. We had to switch to outputting a min and max instead
-- #region DELIVERY tasks
-- local function get_target_id(task_id)
-- 	local var = load_var(db.actor, task_id)
-- 	if var and var.target_id then
-- 		return var.target_id
-- 	end
-- end

local original_on_init_delivery_task = xr_effects.on_init_delivery_task
function xr_effects.on_init_delivery_task(actor,npc,p)
    newline()
    dbg_print("ON_INIT_DELIVERY_TASK")
	original_on_init_delivery_task(actor,npc,p)
	
	
	local task_id = p[1]
    if not task_id then return end

	if not utils.is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		-- RemoveTimeEvent(0,"on_init_delivery_task") 
		RemoveTimeEvent(2,"on_init_delivery_task") 
	end

	CreateTimeEvent(2,"on_init_delivery_task",0,utils.generic_postpone,task_id)
end

-- #endregion

-- TODO: Test MEASURE
--#region MEASURE tasks
local org_measure_setup = tasks_measure.setup_measure_task
function tasks_measure.setup_measure_task(actor, npc, p)
    org_measure_setup(actor, npc, p)

	if not (p and p[1]) then
		printe("! ERROR setup_measure_task missing task_id")
		return false
    end

    local task_id = p[1]
    local org_postpone = tasks_measure.postpone_for_next_frame


	if not utils.is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		-- RemoveTimeEvent(0,"on_init_delivery_task") 
		RemoveTimeEvent(2,"setup_measure_task") 
	end

    -- local function postpone(task_id)
    --     if (utils.is_pda_taskboard_active()) or (not utils.is_supported_task(task_id)) then
    --         -- dbg_print("Not a supported task")
    --         return true
    --     end

    --     local min,max = utils.calc_reward_money(task_id)

    --     local news_caption = utils.ym_get_reward_caption()
    --     local news_text = utils.format_reward_string(min, max)
    --     local news_icon = utils.ym_get_reward_icon()
    --     db.actor:give_talk_message2(news_caption, news_text, news_icon, "iconed_answer_item")

    --     return true
    -- end

	local level_target = alife():level_name(game_graph():vertex(se_target.m_game_vertex_id):level_id())
    local function postpone(task_id, level_target)
        if (utils.is_pda_taskboard_active()) or (not utils.is_supported_task(task_id)) then
            -- cache_task_text(task_id, news_caption, news_text)
            org_postpone(task_id, level_target)
            return true
        end
        
        return utils.generic_postpone(task_id)
    end
	CreateTimeEvent(2,"setup_measure_task",0,postpone,task_id, level_target)
end
--#endregion

--#region PDA TASKBOARD COMPATIBILITY

-- PDA TASKBOARD function
if ui_pda_taskboard_tab then
    local org_get_fetch_task_descr = ui_pda_taskboard_tab.get_long_task_description
    function ui_pda_taskboard_tab.get_long_task_description(task_data)
        newline()
        dbg_print("get_long_task_description")

        local task_id = task_data.task_id
        if not task_id then return org_get_fetch_task_descr(task_data) end
        if utils.ym_cached_tasks_text[task_id] then return utils.ym_cached_tasks_text[task_id] end

        if not utils.is_supported_task(task_id) then return org_get_fetch_task_descr(task_data) end

        dbg_print("task_id = %s", task_id)
        local result = org_get_fetch_task_descr(task_data)
        if result then dbg_print("result = %s", result) end



        -- local actor = db.actor
        local sec_name = db.actor and ui_item.get_sec_name(load_var(db.actor, task_id .. "_fetch", ""))
        -- local sec =  load_var(db.actor, task_id )
        local sec = load_var(db.actor, task_id .. "_fetch", "")
        local count = sec and load_var(db.actor, task_id .. "_fetch_count") or 1
        dbg_print("item = %s, count = %s", sec_name, count)
        if sec then dbg_print("type(sec) = %s, kind = %s",type(sec), utils.get_sec_kind(sec)) end


        -- Reward calculation
        local min_cost, max_cost = utils.calc_reward_money(task_id)
        dbg_print("min_reward = %s", min_cost)
        dbg_print("max_reward = %s", max_cost)


        if (((not min_cost or not max_cost) or (min_cost <= 0))) then
            return org_get_fetch_task_descr(task_data)
        elseif (max_cost <= 0) then
            max_cost = "Unavailable"
        end

        if result then
            local reward_s = utils.combined_caption_and_reward(min_cost, max_cost, task_id) or ""
            local final_s = result .. "\\n" .. reward_s

            utils.cache_task_text(task_id, "", final_s)
            return  final_s
        end
        return org_get_fetch_task_descr(task_id)
    end
end


--#endregion

--#endregion
