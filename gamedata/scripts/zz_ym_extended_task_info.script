--#region debug helpers
local function dbg_print(msg,...)
    if not ym_debug then return end

    ym_debug.set_modname("YM_EXTENDED_TASK_INFO")
    ym_debug.dbg_print(msg,...)
		--exec_console_cmd("flush")
end

-- local function dbg_dump(o)
--     if not ym_debug then return "" end

--     return ym_debug.dbg_dump(o)
-- end
--#endregion

-- #region helper functions
local parse_keys = utils_data.parse_string_keys
local gc = game.translate_string
local newline = function()
    printf("\n")
end
-- imports
local utils = ym_eti_utils


if z_taskboard_overrides then
    dbg_print("PDA TASKBOARD override loaded")
    local pda_taskboard_create_overrides = z_taskboard_overrides.create_overrides
    -- pda_taskboard_create_overrides()
    -- function on_game_start()
    --     RegisterScriptCallback("on_game_load", pda_taskboard_create_overrides)
    -- end
end


--#region PDA TASKBOARD COMPATIBILITY ------
-- Section taken from extended task info by Coverdrave

--[[
	Worth to note that task_id isn't a unique id for each instance of a quest,
	you can think of it as a "template" of a quest.
	Therefore, values in the following table can be overriden,
	but this doesn't seem to be an issue since the previous value has already been used.

	Weird Tasks Framework, however, has an unique id for each quest
	since it concatenates the 'key' (CACHE.description_key) and the
	taskgiver's id.
--]]

-- key = task_id, value = news_text

if z_taskboard_overrides then
    newline()
    dbg_print("PDA TASKBOARD override loaded")
    local tskbrd = z_taskboard_overrides
    -- local pda_taskboard_create_overrides = tskbrd.create_overrides
    
    -- imported from z_taskboard_overrides
    -- local original_give_talk_message2 = db.actor.give_talk_message2
    -- db.actor.give_talk_message2 = function (...)
    --     if ActorMenu.get_pda_menu():IsShown() then
    --         local _, task_title, task_details, task_icon = ...
    --         table.insert(tskbrd.tasks_info, {
    --             task_title = task_title,
    --             task_details = task_details,
    --             task_icon = task_icon
    --         })
    --     else
    --         original_give_talk_message2(...)
    --     end

    -- end

end


if ui_pda_taskboard_tab and ui_pda_taskboard_tab.clear_cached_data then
    local original_clear_cached_data = ui_pda_taskboard_tab.clear_cached_data

    -- Clear cache table on taskboard clear
    function ui_pda_taskboard_tab.clear_cached_data()
        original_clear_cached_data()
        utils.cached_tasks_text = {}
    end
end

--#endregion
--#endregion

-- REWARDS IN DIALOG
--#region

-- TODO: Add reward message to message history
-- ? TODO: Handle dynamic tasks from imporant npcs
-- * Taskboard handles it mostly fine
--// ! PDA Taskboard messages very garbled
--//  ? my fault?
--// * Looks like just the Messages portion is messed up?

-- TODO: patches for artifact fetch task fails
-- Gives double "you have x in inventory messages"

local generic_postpone = utils.generic_postpone

--// TODO: Investigate multifetch_remove function for compatibility
--#region FETCH
local org_fetch_postpone = tasks_fetch.postpone_fetch_for_next_frame
local org_setup_fetch_task = xr_effects.setup_fetch_task
function xr_effects.setup_fetch_task(actor, npc, p)
    org_setup_fetch_task(actor,npc,p)

	local npc = get_speaker(true)
	local npc_id  = npc and npc:id()
    local sec = load_var(db.actor, npc_id .. "_fetch", "")
    local cnt = sec and load_var(db.actor, npc_id .. "_count") or 1

    local function postpone(task_id, section, amount)
        if not task_id then return end
        if string.find(task_id, "_fetch") then
            task_id = string.sub(task_id,1,-7) or "" -- because it ends with fetch
        end

        if (is_pda_taskboard_active()) or (not utils.is_supported_task(task_id)) then
            dbg_print("Not a supported task")
            -- cache_task_text(task_id, news_caption, news_text)
            org_fetch_postpone(task_id, section, amount)
            return true
        end

        local min, max = utils.calc_reward_money(task_id)
        local news_caption = utils.reward_caption or "error"
        local news_text = format_reward_string(min, max)

		db.actor:give_talk_message2(news_caption, news_text, utils.reward_icon, "iconed_answer_item")
        return true
    end

	CreateTimeEvent(1,"setup_fetch_task", 0, postpone, p[1], sec, cnt)
end
--#endregion




--// TODO: finish the rest of the types of dynamic tasks
--// TODO: Test RESCUE
--#region RESCUE AGENT
local org_rescue_setup = tasks_agent_rescue.setup_spy_task
function tasks_agent_rescue.setup_spy_task(actor,npc, p)
	if not (p and p[1]) then
		return false
	end
	local task_id = p[1]

    org_rescue_setup(actor, npc, p)

    CreateTimeEvent(2,"setup_spy_task",0,generic_postpone,task_id)
end

--#endregion

-- TODO: Test ASSAULT 
--#region ASSAULT   
local org_assault_setup = tasks_assault.setup_assault_task
function tasks_assault.setup_assault_task(actor, npc, p)
    dbg_print("SETUP_ASSAULT_TASK init", true)
	if not (p and p[1]) then
		return false
	end

	local task_id = p[1]

    org_assault_setup(actor, npc, p)

    if not is_pda_taskboard_active then 
		RemoveTimeEvent(0,"setup_assault_task") 
    end

    CreateTimeEvent(2,"setup_assault_task",0,generic_postpone,task_id)
end
--#endregion

--// TODO: Test BOUNTY

--#region BOUNTY
local org_bounty_setup = tasks_bounty.setup_bounty_task
function tasks_bounty.setup_bounty_task(actor, npc, p)
    org_bounty_setup(actor, npc, p)

    local task_id = p[1]
    if not task_id then return end

	if not is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		RemoveTimeEvent(0,"setup_bounty_task") 
	end

	-- if is_pda_taskboard_active() then return end

    
	CreateTimeEvent(2,"setup_bounty_task",0,generic_postpone,task_id)
end

--#endregion

-- TODO: Do dominance tasks
--// TODO: Test DOMINANCE
--#region DOMINANCE
local org_dominance_setup = tasks_dominance.setup_dominance_task

--#endregion

-- TODO: Test RIOC
--#region RECOVER ITEM ON CORPSE tasks
--* Note: RIOC tasks have the reward hard-coded into tasks_recover_item_on_corpse:
--* min = 5000
--* max = 7500
local org_recover_item_on_corpse_setup = tasks_recover_item_on_corpse.on_descr

function tasks_recover_item_on_corpse.on_descr(a,b,c)
    dbg_print("RIOC", true)
    org_recover_item_on_corpse_setup(a,b,c)

    local task_id = c[1]
    if not task_id then return end

	local function postpone_for_next_frame(x)
        dbg_print("x = " ..tostring(x))

        local news_caption = utils.reward_caption
		local news_icon = utils.reward_icon
		local news_text = format_reward_string(5000, 7500)


        if  is_pda_taskboard_active then 
            cache_task_text( news_caption, news_text)
            return true
        end

        
		db.actor:give_talk_message2(news_caption, news_text, news_icon, "iconed_answer_item")
		return true
	end
	CreateTimeEvent(2,"on_descr_rioc",0,postpone_for_next_frame, utils_data.read_from_ini(task_manager.task_ini,c[1],'level_name','string'))
end
--#endregion

-- TODO: Test SEARCH
--#region SEARCH STASH
local org_stash_setup = tasks_stash.drx_sl_create_quest_stash
xr_effects.drx_sl_create_quest_stash = function( actor, npc, p )
	if not (p and p[1] and p[2]) then
		return
	end

    if not org_stash_setup then return end
    org_stash_setup(actor, npc, p)

    local task_id = p[1]

	CreateTimeEvent(2,"setup_bounty_task",0,generic_postpone, task_id)
end

--#endregion

--// TODO: Test DELIVERY
--// ! BUG: reward estimate is off by some varying factor, most likely the distance (sweets) factor
--* Reward estimate was off because of the random number generator. We had to switch to outputting a min and max instead
-- #region DELIVERY tasks
-- local function get_target_id(task_id)
-- 	local var = load_var(db.actor, task_id)
-- 	if var and var.target_id then
-- 		return var.target_id
-- 	end
-- end

local original_on_init_delivery_task = xr_effects.on_init_delivery_task
function xr_effects.on_init_delivery_task(actor,npc,p)
    dbg_print("ON_INIT_DELIVERY_TASK", true)
	original_on_init_delivery_task(actor,npc,p)
	
	-- if not is_pda_taskboard_active() then
	-- 	RemoveTimeEvent(0,"on_init_delivery_task")
	-- end
	
	local task_id = p[1]
    if not task_id then return end

	if not is_pda_taskboard_active() then
		-- Removes default time event, which prevents printing of default quest info
		RemoveTimeEvent(0,"on_init_delivery_task") 
	end

	CreateTimeEvent(2,"on_init_delivery_task",0,generic_postpone,task_id)
end

-- #endregion

-- TODO: Test MEASURE
--#region MEASURE tasks
local org_measure_setup = tasks_measure.setup_measure_task
function tasks_measure.setup_measure_task(actor, npc, p)
    org_measure_setup(actor, npc, p)

	if not (p and p[1]) then
		printe("! ERROR setup_measure_task missing task_id")
		return false
    end

    local task_id = p[1]
    local function postpone(task_id)
        if (is_pda_taskboard_active()) or (not is_supported_task(task_id)) then
            -- dbg_print("Not a supported task")
            return true
        end

        local min,max = utils.calc_reward_money(task_id)

        local news_caption = utils.reward_caption
        local news_text = format_reward_string(min, max)
        local news_icon = utils.reward_icon
        db.actor:give_talk_message2(news_caption, news_text, news_icon, "iconed_answer_item")

        return true
    end

	CreateTimeEvent(2,"setup_measure_task",0,postpone,task_id)
end
--#endregion

--#region PDA TASKBOARD COMPATIBILITY

-- PDA TASKBOARD function
if ui_pda_taskboard_tab then
    local org_get_fetch_task_descr = ui_pda_taskboard_tab.get_long_task_description
    function ui_pda_taskboard_tab.get_long_task_description(task_data)
        
        dbg_print("get_long_task_description", true)
        local task_id = task_data.task_id
        if not task_id then return org_get_fetch_task_descr(task_data) end
        if not is_supported_task(task_id) then return org_get_fetch_task_descr(task_data) end

        dbg_print("task_id = " .. tostring(task_id))
        local result = org_get_fetch_task_descr(task_data)
        if result then dbg_print("result = " .. tostring(result)) end



        -- local actor = db.actor
        local sec_name = db.actor and ui_item.get_sec_name(load_var(db.actor, task_id .. "_fetch", ""))
        -- local sec =  load_var(db.actor, task_id )
        local sec = load_var(db.actor, task_id .. "_fetch", "")
        local count = sec and load_var(db.actor, task_id .. "_fetch_count") or 1
        dbg_print("item = " .. tostring(sec_name))
        dbg_print("count = " .. tostring(count))
        if sec then dbg_print("type(sec) = " .. tostring(type(sec))) end

        if sec then dbg_print("kind = " .. tostring(get_sec_kind(sec))) end

        -- Reward calculation
        local min_cost, max_cost = utils.calc_reward_money(task_id)
        dbg_print("min_reward = " .. tostring(min_cost))
        dbg_print("max_reward = " .. tostring(max_cost))


        if (((not min_cost or not max_cost) or (min_cost <= 0))) then
            return org_get_fetch_task_descr(task_data)
        elseif (max_cost <= 0) then
            max_cost = "Unavailable"
        end

        if result then
            local reward_s = combined_caption_and_reward(min_cost, max_cost) or ""

            return result .. "\\n" .. reward_s
        end
        return org_get_fetch_task_descr(task_id)
    end
end


--#endregion

--#endregion
